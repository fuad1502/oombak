#include "dut_bind.h"
#include "dut.hpp"

using namespace std;

static Dut *dut;
static uint32_t *g_words;
extern oombak_sig_t signals[];
extern uint64_t num_of_signals;

oombak_sig_t *oombak_query(uint64_t *_num_of_signals) {
  *_num_of_signals = num_of_signals;
  return signals;
}

void __attribute__((constructor)) startup() {
  dut = new Dut();
}

void __attribute__((destructor)) shutdown() {
  delete dut;
}

oombak_result_t oombak_set(char *sig_name, uint32_t *words, uint64_t num_of_words) {
  vector<uint32_t> v_words;
  for (int i = 0; i < num_of_words; i++)
    v_words.push_back(words[i]);
  if (dut->set(std::string(sig_name), v_words)) {
    return OK;
  } else {
    return ERR;
  }
}

uint32_t *oombak_get(char *sig_name, uint64_t *n_bits) {
  auto res = dut->get(std::string(sig_name));
  if (!res.has_value()) {
    return NULL;
  }
  auto words_v = res.value().first;
  *n_bits = res.value().second;
  free(g_words);
  g_words = (uint32_t *)malloc((*n_bits / 32) + (*n_bits % 32 != 0));
  for (int i = 0; i < words_v.size(); i++)
    g_words[i] = words_v[i];
  return g_words;
}

oombak_result_t oombak_run(uint64_t duration, uint64_t *current_time) {
  auto res = dut->run(duration);
  if (!res.has_value()) {
    return ERR;
  }
  *current_time = res.value();
  return OK;
}
